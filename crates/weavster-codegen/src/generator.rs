//! Rust code generator
//!
//! Converts IR to Rust source code that can be compiled to WASM.

use crate::error::{Error, Result};
use crate::ir::*;

/// Generates Rust source code from IR
pub struct Generator {
    /// Whether to include debug comments in generated code
    debug_comments: bool,
}

impl Generator {
    /// Create a new generator
    pub fn new() -> Self {
        Self {
            debug_comments: false,
        }
    }

    /// Enable debug comments in generated code
    pub fn with_debug_comments(mut self) -> Self {
        self.debug_comments = true;
        self
    }

    /// Generate Rust source code for a flow
    pub fn generate(&self, ir: &FlowIR) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str(&self.generate_header(ir));

        // Imports
        code.push_str(&self.generate_imports(ir));

        // Static data (lookup tables)
        code.push_str(&self.generate_static_data(ir)?);

        // Main transform function
        code.push_str(&self.generate_transform_fn(ir)?);

        // Filter function (if needed)
        if ir.outputs.iter().any(|o| o.condition.is_some()) {
            code.push_str(&self.generate_filter_fns(ir)?);
        }

        Ok(code)
    }

    fn generate_header(&self, ir: &FlowIR) -> String {
        let mut header = String::new();

        header.push_str("// Auto-generated by weavster-codegen\n");
        header.push_str("// DO NOT EDIT - Regenerate with `weavster compile`\n");
        header.push_str(&format!("// Flow: {}\n", ir.name));
        header.push_str(&format!("// Hash: {}\n", ir.content_hash()));
        header.push('\n');
        header.push_str("#![no_std]\n");
        header.push_str("#![allow(unused_imports)]\n");
        header.push('\n');

        header
    }

    fn generate_imports(&self, ir: &FlowIR) -> String {
        let mut imports = String::new();

        imports.push_str("extern crate alloc;\n");
        imports.push_str("use alloc::string::String;\n");
        imports.push_str("use alloc::vec::Vec;\n");
        imports.push_str("use alloc::format;\n");
        imports.push('\n');

        // Core JSON handling
        imports.push_str("use serde_json::{Value, Map};\n");

        // Check if we need regex
        let needs_regex = ir
            .transforms
            .iter()
            .any(|t| matches!(t, TransformIR::Regex(_)));
        if needs_regex {
            imports.push_str("use regex::Regex;\n");
            imports.push_str("use once_cell::sync::Lazy;\n");
        }

        // Check if we need templates
        let needs_template = ir
            .transforms
            .iter()
            .any(|t| matches!(t, TransformIR::Template(_)));
        if needs_template {
            imports.push_str("use minijinja::{Environment, context};\n");
        }

        // Check if we need lookup tables
        let needs_lookup = ir
            .transforms
            .iter()
            .any(|t| matches!(t, TransformIR::Lookup(_)));
        if needs_lookup {
            imports.push_str("use phf::phf_map;\n");
        }

        imports.push('\n');
        imports
    }

    fn generate_static_data(&self, ir: &FlowIR) -> Result<String> {
        let mut code = String::new();

        // Generate static regex patterns
        for (idx, transform) in ir.transforms.iter().enumerate() {
            if let TransformIR::Regex(regex) = transform {
                code.push_str(&format!(
                    "static REGEX_{}: Lazy<Regex> = Lazy::new(|| Regex::new(r#\"{}\"#).unwrap());\n",
                    idx, regex.pattern
                ));
            }
        }

        // Generate static lookup tables from artifacts
        for artifact in &ir.artifacts {
            if let ArtifactData::KeyValue(map) = &artifact.data {
                code.push_str(&format!(
                    "static {}: phf::Map<&'static str, &'static str> = phf_map! {{\n",
                    artifact.name.to_uppercase()
                ));
                for (key, value) in map {
                    code.push_str(&format!("    \"{}\" => \"{}\",\n", key, value));
                }
                code.push_str("};\n");
            }
        }

        if !code.is_empty() {
            code.push('\n');
        }

        Ok(code)
    }

    fn generate_transform_fn(&self, ir: &FlowIR) -> Result<String> {
        let mut code = String::new();

        // Function signature
        code.push_str("/// Transform a message according to the flow definition\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn transform(input_ptr: *const u8, input_len: usize, output_ptr: *mut u8, output_capacity: usize) -> i32 {\n");

        // Input handling
        code.push_str("    // Parse input JSON\n");
        code.push_str(
            "    let input_slice = unsafe { core::slice::from_raw_parts(input_ptr, input_len) };\n",
        );
        code.push_str("    let source: Value = match serde_json::from_slice(input_slice) {\n");
        code.push_str("        Ok(v) => v,\n");
        code.push_str("        Err(_) => return -1, // Parse error\n");
        code.push_str("    };\n");
        code.push('\n');

        // Initialize output
        code.push_str("    let mut output = Map::new();\n");
        code.push('\n');

        // Generate code for each transform
        for (idx, transform) in ir.transforms.iter().enumerate() {
            if self.debug_comments {
                code.push_str(&format!("    // Transform {}\n", idx));
            }

            match transform {
                TransformIR::Map(mappings) => {
                    code.push_str(&self.generate_map_transform(mappings));
                }
                TransformIR::Regex(regex) => {
                    code.push_str(&self.generate_regex_transform(idx, regex));
                }
                TransformIR::Template(templates) => {
                    code.push_str(&self.generate_template_transform(templates)?);
                }
                TransformIR::Lookup(lookup) => {
                    code.push_str(&self.generate_lookup_transform(lookup));
                }
                TransformIR::Filter(filter) => {
                    code.push_str(&self.generate_filter_transform(filter));
                }
                TransformIR::Drop(fields) => {
                    code.push_str(&self.generate_drop_transform(fields));
                }
                TransformIR::Coalesce(fields) => {
                    code.push_str(&self.generate_coalesce_transform(fields));
                }
            }
            code.push('\n');
        }

        // Serialize output
        code.push_str("    // Serialize output\n");
        code.push_str("    let result = Value::Object(output);\n");
        code.push_str("    let output_bytes = match serde_json::to_vec(&result) {\n");
        code.push_str("        Ok(v) => v,\n");
        code.push_str("        Err(_) => return -2, // Serialize error\n");
        code.push_str("    };\n");
        code.push('\n');
        code.push_str("    // Write to output buffer\n");
        code.push_str("    if output_bytes.len() > output_capacity {\n");
        code.push_str("        return -3; // Buffer too small\n");
        code.push_str("    }\n");
        code.push_str("    unsafe {\n");
        code.push_str("        core::ptr::copy_nonoverlapping(\n");
        code.push_str("            output_bytes.as_ptr(),\n");
        code.push_str("            output_ptr,\n");
        code.push_str("            output_bytes.len()\n");
        code.push_str("        );\n");
        code.push_str("    }\n");
        code.push('\n');
        code.push_str("    output_bytes.len() as i32\n");
        code.push_str("}\n");

        Ok(code)
    }

    fn generate_map_transform(&self, mappings: &[FieldMapping]) -> String {
        let mut code = String::new();

        for mapping in mappings {
            let source_path = self.json_path_to_code(&mapping.source);

            if let Some(default) = &mapping.default {
                code.push_str(&format!(
                    "    output.insert(\"{}\".into(), source{}.clone().unwrap_or(serde_json::json!({})));\n",
                    mapping.target, source_path, default
                ));
            } else {
                code.push_str(&format!("    if let Some(v) = source{} {{\n", source_path));
                code.push_str(&format!(
                    "        output.insert(\"{}\".into(), v.clone());\n",
                    mapping.target
                ));
                code.push_str("    }\n");
            }
        }

        code
    }

    fn generate_regex_transform(&self, idx: usize, regex: &RegexTransform) -> String {
        let mut code = String::new();

        code.push_str(&format!(
            "    if let Some(text) = source[\"{}\"].as_str() {{\n",
            regex.source_field
        ));
        code.push_str(&format!(
            "        if let Some(caps) = REGEX_{}.captures(text) {{\n",
            idx
        ));

        for (output_field, capture) in &regex.captures {
            let capture_code = match &capture.group {
                CaptureGroup::Index(i) => format!("caps.get({})", i),
                CaptureGroup::Named(n) => format!("caps.name(\"{}\")", n),
            };

            code.push_str(&format!(
                "            if let Some(m) = {} {{\n",
                capture_code
            ));
            code.push_str(&format!(
                "                output.insert(\"{}\".into(), Value::String(m.as_str().into()));\n",
                output_field
            ));
            code.push_str("            }\n");
        }

        code.push_str("        }\n");
        code.push_str("    }\n");

        code
    }

    fn generate_template_transform(&self, templates: &[TemplateField]) -> Result<String> {
        let mut code = String::new();

        code.push_str("    {\n");
        code.push_str("        let env = Environment::new();\n");

        for template in templates {
            // Validate template at compile time
            minijinja::Environment::new()
                .render_str(&template.template, minijinja::context!())
                .map_err(Error::InvalidTemplate)?;

            code.push_str(&format!(
                "        if let Ok(rendered) = env.render_str(r#\"{}\"#, &source) {{\n",
                template.template
            ));
            code.push_str(&format!(
                "            output.insert(\"{}\".into(), Value::String(rendered));\n",
                template.target
            ));
            code.push_str("        }\n");
        }

        code.push_str("    }\n");

        Ok(code)
    }

    fn generate_lookup_transform(&self, lookup: &LookupTransform) -> String {
        let mut code = String::new();

        code.push_str(&format!(
            "    if let Some(key) = source[\"{}\"].as_str() {{\n",
            lookup.key_field
        ));
        code.push_str(&format!(
            "        if let Some(value) = {}.get(key) {{\n",
            lookup.table.to_uppercase()
        ));
        code.push_str(&format!(
            "            output.insert(\"{}\".into(), Value::String((*value).into()));\n",
            lookup.output_field
        ));

        if let Some(default) = &lookup.default {
            code.push_str("        } else {\n");
            code.push_str(&format!(
                "            output.insert(\"{}\".into(), serde_json::json!({}));\n",
                lookup.output_field, default
            ));
        }

        code.push_str("        }\n");
        code.push_str("    }\n");

        code
    }

    fn generate_filter_transform(&self, _filter: &FilterTransform) -> String {
        // Filters are handled at the flow level, not in transform code
        // This is a pass-through placeholder
        String::new()
    }

    fn generate_drop_transform(&self, fields: &[String]) -> String {
        let mut code = String::new();

        for field in fields {
            code.push_str(&format!("    output.remove(\"{}\");\n", field));
        }

        code
    }

    fn generate_coalesce_transform(&self, fields: &[CoalesceField]) -> String {
        let mut code = String::new();

        for field in fields {
            code.push_str(&format!("    // Coalesce for {}\n", field.target));
            code.push_str("    'coalesce: {\n");

            for source in &field.sources {
                let source_path = self.json_path_to_code(source);
                code.push_str(&format!(
                    "        if let Some(v) = source{} {{\n",
                    source_path
                ));
                code.push_str("            if !v.is_null() {\n");
                code.push_str(&format!(
                    "                output.insert(\"{}\".into(), v.clone());\n",
                    field.target
                ));
                code.push_str("                break 'coalesce;\n");
                code.push_str("            }\n");
                code.push_str("        }\n");
            }

            code.push_str("    }\n");
        }

        code
    }

    fn generate_filter_fns(&self, ir: &FlowIR) -> Result<String> {
        let mut code = String::new();

        for (idx, output) in ir.outputs.iter().enumerate() {
            if let Some(condition) = &output.condition {
                code.push_str(&format!(
                    "\n/// Filter function for output {}\n",
                    output.connector
                ));
                code.push_str("#[no_mangle]\n");
                code.push_str(&format!(
                    "pub extern \"C\" fn filter_{}(input_ptr: *const u8, input_len: usize) -> bool {{\n",
                    idx
                ));
                code.push_str("    let input_slice = unsafe { core::slice::from_raw_parts(input_ptr, input_len) };\n");
                code.push_str(
                    "    let source: Value = match serde_json::from_slice(input_slice) {\n",
                );
                code.push_str("        Ok(v) => v,\n");
                code.push_str("        Err(_) => return false,\n");
                code.push_str("    };\n");
                code.push('\n');

                // Generate condition check
                if let FilterCondition::Expression(expr) = condition {
                    code.push_str(&format!("    // Expression: {}\n", expr));
                    code.push_str("    // TODO: Generate proper expression evaluation\n");
                    code.push_str("    true\n");
                }

                code.push_str("}\n");
            }
        }

        Ok(code)
    }

    /// Convert a JSON path like "source.customer.id" to Rust indexing code
    fn json_path_to_code(&self, path: &str) -> String {
        let parts: Vec<&str> = path.split('.').collect();
        let mut code = String::new();

        for part in parts {
            code.push_str(&format!("[\"{}\"]", part));
        }

        code
    }
}

impl Default for Generator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_simple_flow() {
        let mut ir = FlowIR::new("test");
        ir.input = "kafka.orders".to_string();
        ir.transforms.push(TransformIR::Map(vec![FieldMapping {
            target: "customer_id".to_string(),
            source: "cust_id".to_string(),
            default: None,
        }]));
        ir.outputs.push(OutputIR {
            connector: "postgres.orders".to_string(),
            condition: None,
        });

        let generator = Generator::new();
        let code = generator.generate(&ir).unwrap();

        assert!(code.contains("pub extern \"C\" fn transform"));
        assert!(code.contains("customer_id"));
    }
}
