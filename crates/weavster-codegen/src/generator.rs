//! Rust code generator
//!
//! Converts IR to Rust source code that can be compiled to WASM.

use crate::error::{Error, Result};
use crate::ir::*;

/// Generates Rust source code from IR
pub struct Generator {
    /// Whether to include debug comments in generated code
    debug_comments: bool,
}

impl Generator {
    /// Create a new generator
    pub fn new() -> Self {
        Self {
            debug_comments: false,
        }
    }

    /// Enable debug comments in generated code
    pub fn with_debug_comments(mut self) -> Self {
        self.debug_comments = true;
        self
    }

    /// Generate Rust source code for a flow
    pub fn generate(&self, ir: &FlowIR) -> Result<String> {
        let mut code = String::new();

        // File header
        code.push_str(&self.generate_header(ir));

        // Imports
        code.push_str(&self.generate_imports(ir));

        // Static data (lookup tables)
        code.push_str(&self.generate_static_data(ir)?);

        // Main transform function
        code.push_str(&self.generate_transform_fn(ir)?);

        // Filter function (if needed)
        if ir.outputs.iter().any(|o| o.condition.is_some()) {
            code.push_str(&self.generate_filter_fns(ir)?);
        }

        Ok(code)
    }

    fn generate_header(&self, ir: &FlowIR) -> String {
        let mut header = String::new();

        header.push_str("// Auto-generated by weavster-codegen\n");
        header.push_str("// DO NOT EDIT - Regenerate with `weavster compile`\n");
        header.push_str(&format!("// Flow: {}\n", ir.name));
        header.push_str(&format!("// Hash: {}\n", ir.content_hash()));
        header.push('\n');
        header.push_str("#![no_std]\n");
        header.push_str("#![allow(unused_imports)]\n");
        header.push('\n');

        header
    }

    fn generate_imports(&self, ir: &FlowIR) -> String {
        let mut imports = String::new();

        imports.push_str("extern crate alloc;\n");
        imports.push_str("use alloc::string::String;\n");
        imports.push_str("use alloc::vec::Vec;\n");
        imports.push_str("use alloc::format;\n");
        imports.push('\n');

        // Core JSON handling
        imports.push_str("use serde_json::{Value, Map};\n");

        // Check if we need regex
        let needs_regex = ir
            .transforms
            .iter()
            .any(|t| matches!(t, TransformIR::Regex(_)));
        if needs_regex {
            imports.push_str("use regex::Regex;\n");
            imports.push_str("use once_cell::sync::Lazy;\n");
        }

        // Check if we need templates
        let needs_template = ir
            .transforms
            .iter()
            .any(|t| matches!(t, TransformIR::Template(_)));
        if needs_template {
            imports.push_str("use minijinja::{Environment, context};\n");
        }

        // Check if we need lookup tables
        let needs_lookup = ir
            .transforms
            .iter()
            .any(|t| matches!(t, TransformIR::Lookup(_)));
        if needs_lookup {
            imports.push_str("use phf::phf_map;\n");
        }

        imports.push('\n');
        imports
    }

    fn generate_static_data(&self, ir: &FlowIR) -> Result<String> {
        let mut code = String::new();

        // Generate static regex patterns
        for (idx, transform) in ir.transforms.iter().enumerate() {
            if let TransformIR::Regex(regex) = transform {
                code.push_str(&format!(
                    "static REGEX_{}: Lazy<Regex> = Lazy::new(|| Regex::new(r#\"{}\"#).unwrap());\n",
                    idx, regex.pattern
                ));
            }
        }

        // Generate static lookup tables from artifacts
        for artifact in &ir.artifacts {
            if let ArtifactData::KeyValue(map) = &artifact.data {
                code.push_str(&format!(
                    "static {}: phf::Map<&'static str, &'static str> = phf_map! {{\n",
                    artifact.name.to_uppercase()
                ));
                for (key, value) in map {
                    code.push_str(&format!("    \"{}\" => \"{}\",\n", key, value));
                }
                code.push_str("};\n");
            }
        }

        if !code.is_empty() {
            code.push('\n');
        }

        Ok(code)
    }

    fn generate_transform_fn(&self, ir: &FlowIR) -> Result<String> {
        let mut code = String::new();

        // Function signature
        code.push_str("/// Transform a message according to the flow definition\n");
        code.push_str("#[no_mangle]\n");
        code.push_str("pub extern \"C\" fn transform(input_ptr: *const u8, input_len: usize, output_ptr: *mut u8, output_capacity: usize) -> i32 {\n");

        // Input handling
        code.push_str("    // Parse input JSON\n");
        code.push_str(
            "    let input_slice = unsafe { core::slice::from_raw_parts(input_ptr, input_len) };\n",
        );
        code.push_str("    let source: Value = match serde_json::from_slice(input_slice) {\n");
        code.push_str("        Ok(v) => v,\n");
        code.push_str("        Err(_) => return -1, // Parse error\n");
        code.push_str("    };\n");
        code.push('\n');

        // Initialize output
        code.push_str("    let mut output = Map::new();\n");
        code.push('\n');

        // Generate code for each transform
        for (idx, transform) in ir.transforms.iter().enumerate() {
            if self.debug_comments {
                code.push_str(&format!("    // Transform {}\n", idx));
            }

            match transform {
                TransformIR::Map(mappings) => {
                    code.push_str(&self.generate_map_transform(mappings));
                }
                TransformIR::Regex(regex) => {
                    code.push_str(&self.generate_regex_transform(idx, regex));
                }
                TransformIR::Template(templates) => {
                    code.push_str(&self.generate_template_transform(templates)?);
                }
                TransformIR::Lookup(lookup) => {
                    code.push_str(&self.generate_lookup_transform(lookup));
                }
                TransformIR::Filter(filter) => {
                    code.push_str(&self.generate_filter_transform(filter));
                }
                TransformIR::Drop(fields) => {
                    code.push_str(&self.generate_drop_transform(fields));
                }
                TransformIR::Coalesce(fields) => {
                    code.push_str(&self.generate_coalesce_transform(fields));
                }
            }
            code.push('\n');
        }

        // Serialize output
        code.push_str("    // Serialize output\n");
        code.push_str("    let result = Value::Object(output);\n");
        code.push_str("    let output_bytes = match serde_json::to_vec(&result) {\n");
        code.push_str("        Ok(v) => v,\n");
        code.push_str("        Err(_) => return -2, // Serialize error\n");
        code.push_str("    };\n");
        code.push('\n');
        code.push_str("    // Write to output buffer\n");
        code.push_str("    if output_bytes.len() > output_capacity {\n");
        code.push_str("        return -3; // Buffer too small\n");
        code.push_str("    }\n");
        code.push_str("    unsafe {\n");
        code.push_str("        core::ptr::copy_nonoverlapping(\n");
        code.push_str("            output_bytes.as_ptr(),\n");
        code.push_str("            output_ptr,\n");
        code.push_str("            output_bytes.len()\n");
        code.push_str("        );\n");
        code.push_str("    }\n");
        code.push('\n');
        code.push_str("    output_bytes.len() as i32\n");
        code.push_str("}\n");

        Ok(code)
    }

    fn generate_map_transform(&self, mappings: &[FieldMapping]) -> String {
        let mut code = String::new();

        for mapping in mappings {
            let source_path = self.json_path_to_code(&mapping.source);

            if let Some(default) = &mapping.default {
                code.push_str(&format!(
                    "    output.insert(\"{}\".into(), source{}.clone().unwrap_or(serde_json::json!({})));\n",
                    mapping.target, source_path, default
                ));
            } else {
                code.push_str(&format!("    if let Some(v) = source{} {{\n", source_path));
                code.push_str(&format!(
                    "        output.insert(\"{}\".into(), v.clone());\n",
                    mapping.target
                ));
                code.push_str("    }\n");
            }
        }

        code
    }

    fn generate_regex_transform(&self, idx: usize, regex: &RegexTransform) -> String {
        let mut code = String::new();

        code.push_str(&format!(
            "    if let Some(text) = source[\"{}\"].as_str() {{\n",
            regex.source_field
        ));
        code.push_str(&format!(
            "        if let Some(caps) = REGEX_{}.captures(text) {{\n",
            idx
        ));

        for (output_field, capture) in &regex.captures {
            let capture_code = match &capture.group {
                CaptureGroup::Index(i) => format!("caps.get({})", i),
                CaptureGroup::Named(n) => format!("caps.name(\"{}\")", n),
            };

            code.push_str(&format!(
                "            if let Some(m) = {} {{\n",
                capture_code
            ));
            code.push_str(&format!(
                "                output.insert(\"{}\".into(), Value::String(m.as_str().into()));\n",
                output_field
            ));
            code.push_str("            }\n");
        }

        code.push_str("        }\n");
        code.push_str("    }\n");

        code
    }

    fn generate_template_transform(&self, templates: &[TemplateField]) -> Result<String> {
        let mut code = String::new();

        code.push_str("    {\n");
        code.push_str("        let env = Environment::new();\n");

        for template in templates {
            // Validate template at compile time
            minijinja::Environment::new()
                .render_str(&template.template, minijinja::context!())
                .map_err(Error::InvalidTemplate)?;

            code.push_str(&format!(
                "        if let Ok(rendered) = env.render_str(r#\"{}\"#, &source) {{\n",
                template.template
            ));
            code.push_str(&format!(
                "            output.insert(\"{}\".into(), Value::String(rendered));\n",
                template.target
            ));
            code.push_str("        }\n");
        }

        code.push_str("    }\n");

        Ok(code)
    }

    fn generate_lookup_transform(&self, lookup: &LookupTransform) -> String {
        let mut code = String::new();

        code.push_str(&format!(
            "    if let Some(key) = source[\"{}\"].as_str() {{\n",
            lookup.key_field
        ));
        code.push_str(&format!(
            "        if let Some(value) = {}.get(key) {{\n",
            lookup.table.to_uppercase()
        ));
        code.push_str(&format!(
            "            output.insert(\"{}\".into(), Value::String((*value).into()));\n",
            lookup.output_field
        ));

        if let Some(default) = &lookup.default {
            code.push_str("        } else {\n");
            code.push_str(&format!(
                "            output.insert(\"{}\".into(), serde_json::json!({}));\n",
                lookup.output_field, default
            ));
        }

        code.push_str("        }\n");
        code.push_str("    }\n");

        code
    }

    fn generate_filter_transform(&self, _filter: &FilterTransform) -> String {
        // Filters are handled at the flow level, not in transform code
        // This is a pass-through placeholder
        String::new()
    }

    fn generate_drop_transform(&self, fields: &[String]) -> String {
        let mut code = String::new();

        for field in fields {
            code.push_str(&format!("    output.remove(\"{}\");\n", field));
        }

        code
    }

    fn generate_coalesce_transform(&self, fields: &[CoalesceField]) -> String {
        let mut code = String::new();

        for field in fields {
            code.push_str(&format!("    // Coalesce for {}\n", field.target));
            code.push_str("    'coalesce: {\n");

            for source in &field.sources {
                let source_path = self.json_path_to_code(source);
                code.push_str(&format!(
                    "        if let Some(v) = source{} {{\n",
                    source_path
                ));
                code.push_str("            if !v.is_null() {\n");
                code.push_str(&format!(
                    "                output.insert(\"{}\".into(), v.clone());\n",
                    field.target
                ));
                code.push_str("                break 'coalesce;\n");
                code.push_str("            }\n");
                code.push_str("        }\n");
            }

            code.push_str("    }\n");
        }

        code
    }

    fn generate_filter_fns(&self, ir: &FlowIR) -> Result<String> {
        let mut code = String::new();

        for (idx, output) in ir.outputs.iter().enumerate() {
            if let Some(condition) = &output.condition {
                code.push_str(&format!(
                    "\n/// Filter function for output {}\n",
                    output.connector
                ));
                code.push_str("#[no_mangle]\n");
                code.push_str(&format!(
                    "pub extern \"C\" fn filter_{}(input_ptr: *const u8, input_len: usize) -> bool {{\n",
                    idx
                ));
                code.push_str("    let input_slice = unsafe { core::slice::from_raw_parts(input_ptr, input_len) };\n");
                code.push_str(
                    "    let source: Value = match serde_json::from_slice(input_slice) {\n",
                );
                code.push_str("        Ok(v) => v,\n");
                code.push_str("        Err(_) => return false,\n");
                code.push_str("    };\n");
                code.push('\n');

                // Generate condition check
                if let FilterCondition::Expression(expr) = condition {
                    code.push_str(&format!("    // Expression: {}\n", expr));
                    code.push_str("    // TODO: Generate proper expression evaluation\n");
                    code.push_str("    true\n");
                }

                code.push_str("}\n");
            }
        }

        Ok(code)
    }

    /// Convert a JSON path like "source.customer.id" to Rust indexing code
    fn json_path_to_code(&self, path: &str) -> String {
        let parts: Vec<&str> = path.split('.').collect();
        let mut code = String::new();

        for part in parts {
            code.push_str(&format!("[\"{}\"]", part));
        }

        code
    }
}

impl Default for Generator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_generator_new() {
        let generator = Generator::new();
        assert!(!generator.debug_comments);
    }

    #[test]
    fn test_generator_with_debug_comments() {
        let generator = Generator::new().with_debug_comments();
        assert!(generator.debug_comments);
    }

    #[test]
    fn test_generator_default() {
        let generator = Generator::default();
        assert!(!generator.debug_comments);
    }

    #[test]
    fn test_generate_simple_flow() {
        let mut ir = FlowIR::new("test");
        ir.input = "kafka.orders".to_string();
        ir.transforms.push(TransformIR::Map(vec![FieldMapping {
            target: "customer_id".to_string(),
            source: "cust_id".to_string(),
            default: None,
        }]));
        ir.outputs.push(OutputIR {
            connector: "postgres.orders".to_string(),
            condition: None,
        });

        let generator = Generator::new();
        let code = generator.generate(&ir).unwrap();

        assert!(code.contains("pub extern \"C\" fn transform"));
        assert!(code.contains("customer_id"));
    }

    #[test]
    fn test_generate_header() {
        let ir = FlowIR::new("my_flow");
        let generator = Generator::new();
        let header = generator.generate_header(&ir);

        assert!(header.contains("Auto-generated by weavster-codegen"));
        assert!(header.contains("Flow: my_flow"));
        assert!(header.contains("#![no_std]"));
    }

    #[test]
    fn test_generate_imports_basic() {
        let ir = FlowIR::new("test");
        let generator = Generator::new();
        let imports = generator.generate_imports(&ir);

        assert!(imports.contains("extern crate alloc"));
        assert!(imports.contains("use serde_json::{Value, Map}"));
        // No regex/template/lookup since transforms are empty
        assert!(!imports.contains("use regex::Regex"));
        assert!(!imports.contains("use minijinja"));
        assert!(!imports.contains("use phf::phf_map"));
    }

    #[test]
    fn test_generate_imports_with_regex() {
        let mut ir = FlowIR::new("test");
        ir.transforms.push(TransformIR::Regex(RegexTransform {
            source_field: "text".to_string(),
            pattern: r"\d+".to_string(),
            captures: HashMap::new(),
            on_no_match: NoMatchBehavior::Null,
        }));

        let generator = Generator::new();
        let imports = generator.generate_imports(&ir);

        assert!(imports.contains("use regex::Regex"));
        assert!(imports.contains("use once_cell::sync::Lazy"));
    }

    #[test]
    fn test_generate_imports_with_template() {
        let mut ir = FlowIR::new("test");
        ir.transforms
            .push(TransformIR::Template(vec![TemplateField {
                target: "greeting".to_string(),
                template: "Hello!".to_string(),
            }]));

        let generator = Generator::new();
        let imports = generator.generate_imports(&ir);

        assert!(imports.contains("use minijinja::{Environment, context}"));
    }

    #[test]
    fn test_generate_imports_with_lookup() {
        let mut ir = FlowIR::new("test");
        ir.transforms.push(TransformIR::Lookup(LookupTransform {
            key_field: "code".to_string(),
            table: "codes".to_string(),
            key_column: None,
            value_column: None,
            output_field: "name".to_string(),
            default: None,
        }));

        let generator = Generator::new();
        let imports = generator.generate_imports(&ir);

        assert!(imports.contains("use phf::phf_map"));
    }

    #[test]
    fn test_generate_static_data_empty() {
        let ir = FlowIR::new("test");
        let generator = Generator::new();
        let static_data = generator.generate_static_data(&ir).unwrap();

        assert!(static_data.is_empty());
    }

    #[test]
    fn test_generate_static_data_with_regex() {
        let mut ir = FlowIR::new("test");
        ir.transforms.push(TransformIR::Regex(RegexTransform {
            source_field: "text".to_string(),
            pattern: r"(\d+)-(\w+)".to_string(),
            captures: HashMap::new(),
            on_no_match: NoMatchBehavior::Null,
        }));

        let generator = Generator::new();
        let static_data = generator.generate_static_data(&ir).unwrap();

        assert!(static_data.contains("static REGEX_0"));
        assert!(static_data.contains(r"(\d+)-(\w+)"));
    }

    #[test]
    fn test_generate_static_data_with_artifact() {
        let mut ir = FlowIR::new("test");
        let mut map = HashMap::new();
        map.insert("A".to_string(), "Alpha".to_string());
        map.insert("B".to_string(), "Beta".to_string());

        ir.artifacts.push(ArtifactIR {
            name: "letters".to_string(),
            kind: ArtifactKind::LookupTable,
            data: ArtifactData::KeyValue(map),
        });

        let generator = Generator::new();
        let static_data = generator.generate_static_data(&ir).unwrap();

        assert!(static_data.contains("static LETTERS: phf::Map"));
        assert!(static_data.contains("\"A\" => \"Alpha\""));
        assert!(static_data.contains("\"B\" => \"Beta\""));
    }

    #[test]
    fn test_generate_map_transform() {
        let mappings = vec![
            FieldMapping {
                target: "id".to_string(),
                source: "customer_id".to_string(),
                default: None,
            },
            FieldMapping {
                target: "name".to_string(),
                source: "customer_name".to_string(),
                default: Some(serde_json::json!("Unknown")),
            },
        ];

        let generator = Generator::new();
        let code = generator.generate_map_transform(&mappings);

        assert!(code.contains("output.insert(\"id\""));
        assert!(code.contains("[\"customer_id\"]"));
        assert!(code.contains("output.insert(\"name\""));
        assert!(code.contains("unwrap_or"));
    }

    #[test]
    fn test_generate_regex_transform() {
        let mut captures = HashMap::new();
        captures.insert(
            "digits".to_string(),
            CaptureMapping {
                group: CaptureGroup::Index(1),
                transform: None,
            },
        );
        captures.insert(
            "word".to_string(),
            CaptureMapping {
                group: CaptureGroup::Named("word".to_string()),
                transform: None,
            },
        );

        let regex = RegexTransform {
            source_field: "input".to_string(),
            pattern: r"(\d+)-(?P<word>\w+)".to_string(),
            captures,
            on_no_match: NoMatchBehavior::Null,
        };

        let generator = Generator::new();
        let code = generator.generate_regex_transform(0, &regex);

        assert!(code.contains("source[\"input\"]"));
        assert!(code.contains("REGEX_0.captures"));
        assert!(code.contains("caps.get(1)"));
        assert!(code.contains("caps.name(\"word\")"));
    }

    #[test]
    fn test_generate_lookup_transform() {
        let lookup = LookupTransform {
            key_field: "code".to_string(),
            table: "translations".to_string(),
            key_column: None,
            value_column: None,
            output_field: "description".to_string(),
            default: None,
        };

        let generator = Generator::new();
        let code = generator.generate_lookup_transform(&lookup);

        assert!(code.contains("source[\"code\"]"));
        assert!(code.contains("TRANSLATIONS.get(key)"));
        assert!(code.contains("output.insert(\"description\""));
    }

    #[test]
    fn test_generate_lookup_transform_with_default() {
        let lookup = LookupTransform {
            key_field: "code".to_string(),
            table: "translations".to_string(),
            key_column: None,
            value_column: None,
            output_field: "description".to_string(),
            default: Some(serde_json::json!("N/A")),
        };

        let generator = Generator::new();
        let code = generator.generate_lookup_transform(&lookup);

        assert!(code.contains("} else {"));
        assert!(code.contains("N/A"));
    }

    #[test]
    fn test_generate_drop_transform() {
        let fields = vec!["secret".to_string(), "internal_id".to_string()];

        let generator = Generator::new();
        let code = generator.generate_drop_transform(&fields);

        assert!(code.contains("output.remove(\"secret\")"));
        assert!(code.contains("output.remove(\"internal_id\")"));
    }

    #[test]
    fn test_generate_coalesce_transform() {
        let fields = vec![CoalesceField {
            target: "name".to_string(),
            sources: vec![
                "preferred_name".to_string(),
                "display_name".to_string(),
                "first_name".to_string(),
            ],
        }];

        let generator = Generator::new();
        let code = generator.generate_coalesce_transform(&fields);

        assert!(code.contains("Coalesce for name"));
        assert!(code.contains("'coalesce"));
        assert!(code.contains("[\"preferred_name\"]"));
        assert!(code.contains("[\"display_name\"]"));
        assert!(code.contains("[\"first_name\"]"));
        assert!(code.contains("break 'coalesce"));
    }

    #[test]
    fn test_generate_filter_transform() {
        let filter = FilterTransform {
            condition: FilterCondition::NotNull("id".to_string()),
        };

        let generator = Generator::new();
        let code = generator.generate_filter_transform(&filter);

        // Filter transforms are handled at flow level, so this should be empty
        assert!(code.is_empty());
    }

    #[test]
    fn test_generate_filter_fns() {
        let mut ir = FlowIR::new("test");
        ir.outputs.push(OutputIR {
            connector: "output1".to_string(),
            condition: Some(FilterCondition::Expression(
                "status == 'active'".to_string(),
            )),
        });

        let generator = Generator::new();
        let code = generator.generate_filter_fns(&ir).unwrap();

        assert!(code.contains("pub extern \"C\" fn filter_0"));
        assert!(code.contains("status == 'active'"));
    }

    #[test]
    fn test_json_path_to_code_simple() {
        let generator = Generator::new();
        let code = generator.json_path_to_code("name");

        assert_eq!(code, "[\"name\"]");
    }

    #[test]
    fn test_json_path_to_code_nested() {
        let generator = Generator::new();
        let code = generator.json_path_to_code("customer.address.city");

        assert_eq!(code, "[\"customer\"][\"address\"][\"city\"]");
    }

    #[test]
    fn test_generate_with_debug_comments() {
        let mut ir = FlowIR::new("test");
        ir.input = "input".to_string();
        ir.transforms.push(TransformIR::Map(vec![FieldMapping {
            target: "id".to_string(),
            source: "id".to_string(),
            default: None,
        }]));
        ir.outputs.push(OutputIR {
            connector: "output".to_string(),
            condition: None,
        });

        let generator = Generator::new().with_debug_comments();
        let code = generator.generate(&ir).unwrap();

        assert!(code.contains("// Transform 0"));
    }

    #[test]
    fn test_generate_template_transform() {
        let templates = vec![TemplateField {
            target: "greeting".to_string(),
            template: "Hello, World!".to_string(),
        }];

        let generator = Generator::new();
        let code = generator.generate_template_transform(&templates).unwrap();

        assert!(code.contains("Environment::new()"));
        assert!(code.contains("env.render_str"));
        assert!(code.contains("Hello, World!"));
        assert!(code.contains("output.insert(\"greeting\""));
    }

    #[test]
    fn test_generate_full_flow_with_all_transforms() {
        let mut ir = FlowIR::new("comprehensive_flow");
        ir.input = "kafka.input".to_string();
        ir.description = Some("A comprehensive test flow".to_string());

        // Map transform
        ir.transforms.push(TransformIR::Map(vec![FieldMapping {
            target: "user_id".to_string(),
            source: "id".to_string(),
            default: None,
        }]));

        // Drop transform
        ir.transforms
            .push(TransformIR::Drop(vec!["internal".to_string()]));

        // Coalesce transform
        ir.transforms
            .push(TransformIR::Coalesce(vec![CoalesceField {
                target: "email".to_string(),
                sources: vec!["primary_email".to_string(), "secondary_email".to_string()],
            }]));

        ir.outputs.push(OutputIR {
            connector: "postgres.users".to_string(),
            condition: None,
        });

        let generator = Generator::new();
        let code = generator.generate(&ir).unwrap();

        assert!(code.contains("#![no_std]"));
        assert!(code.contains("pub extern \"C\" fn transform"));
        assert!(code.contains("user_id"));
        assert!(code.contains("output.remove(\"internal\")"));
        assert!(code.contains("'coalesce"));
    }
}
